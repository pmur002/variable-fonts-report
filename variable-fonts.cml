<?xml version="1.0" encoding="utf-8"?>
<html>
<head>
  <title>Variable Fonts in R Graphics</title>
  <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
    p.fig {
      text-align: left;
    }
    p.fig img, img.plot {
      box-shadow: 10px 10px 20px;
      margin-top: 10px;
      margin-bottom: 20px;      
    }
  </style>
  <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>

</head>
<body>
  <h1>Variable Fonts in R Graphics</h1>
  <p>
    <span style="font-style: italic">by Paul Murrell</span>
    <a href="http://orcid.org"><img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle" /></a> <span style="font-family: mono; font-size: small"><a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a></span>
  </p>
  <p class="date">
    Version 1:  
    <rcode echo="FALSE" results="asis">
cat(format(Sys.Date(), "%A %d %B %Y"))
    </rcode>
  </p>

  <rcode id="init" echo="FALSE" message="FALSE" results="hide">
opts_chunk$set(comment=" ", tidy=FALSE, 
               dev="png", ## dev="svg",
               dpi=96)
options(width=100)
## For wonky desktop set up
options(bitmapType="cairo")
  </rcode>
  <rcode echo="FALSE" message="FALSE">
    library(grid)
  </rcode>

  <hr/>
  <p>
    <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/"><img class="CC"
    alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span
    xmlns:dct="http://purl.org/dc/terms/"
    property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#"
    property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
  <hr/>
  <p>
    This document describes the addition of support for variable fonts
    in R, when rendering glyphs, plus changes to the CRAN package <str>xdvir</str> 
    to take advantage of that new support, when rendering LaTeX fragments.
  </p>

  <toc/>

  <h2><a name="intro">Introduction</a></h2>

  <p>
    Since R version 4.3.0 (<a href="#R"/>), it has been possible
    to render text from a set of typeset glyph information, using
    functions <code>grDevices::glyphFont()</code> to specify a font,
    <code>grDevices::grid.glyphInfo()</code> to specify glyphs within the font
    and a position for each glyph, and
    <code>grid::grid.glyph()</code> to do the drawing.
    For example, the following code draws the letter "t" 
    (glyph number 409) from (a local copy of)
    the Google font 
    <a href="https://fonts.google.com/specimen/Recursive">Recursive</a>.
  </p>

  <rcode>
library(grid)
  </rcode>
  <rcode>
fontpath <- file.path(getwd(), "Fonts", "Recursive-VariableFont.ttf")
  </rcode>
  <rcode fig.width="1" fig.height="1">
font <- glyphFont(fontpath, 0, "Recursive", 400, "normal", PSname="Recursive")
info <- glyphInfo(id=409, x=0, y=0, font=1, size=10,
                  fontList=glyphFontList(font), width=8, height=12)
grid.newpage()
grid.glyph(info)
  </rcode>

  <p>
    In the development version of R, to become version 4.6.0,
    support has been added for using variable fonts when rendering glyphs.
    This comes in the form of a new argument called 
    <code>variations</code> for the 
    <code>grDevices::glyphFont()</code>
    function, which allows variations on a font to be specified.
    For example, the following code draws the letter "t" using the
    Recursive font, as before, but this time specifies a very bold
    variation of the font.  The variation <code>wght=900</code> means a weight
    of 900 (out of 1000).  For comparison, a normal font weight is
    typically 400 and a bold font weight is typically 700.
  </p>
  <rcode fig.width="1" fig.height="1">
boldFont <- glyphFont(fontpath, 0, "Recursive", 400, "normal", PSname="Recursive",
                      variations=c(wght=900))
info <- glyphInfo(id=409, x=0, y=0, font=1, size=10,
                  fontList=glyphFontList(boldFont), width=8, height=12)
grid.newpage()
grid.glyph(info)
  </rcode>

  <p>
    This means that it is now possible to make use of variable
    fonts when drawing text in R graphics
    (in the development version of R),
    although support is currently limited to Cairo-based graphics devices
    (except for <code>cairo_pdf()</code>) and the <code>quartz()</code>
    graphics device.
  </p>
  <p>
    However, we may be left wondering what we could use variable fonts
    for and how we might use them without specifying every single 
    glyph and every single glyph position for the text that we want 
    to draw.
  </p>
  <p>
    This report explains what variable fonts are,
    demonstrates new features in the <str>xdvir</str> package that
    allow users to make use of variable fonts when drawing 
    text in R graphics, and provides an example use of 
    variable fonts in statistical plots.
  </p>

  <h2><a name="varfonts">Variable fonts</a></h2>

  <p>
    Most fonts are available in multiple variations,
    such as italic or bold,
    but usually each variation is provided as a separate font file.
    For example, on the system used to build this report,
    there are four variations on the <code>NotoSans</code> font
    in four separate files:
  </p>
  <rcode echo="FALSE" results="asis">
cat("<pre>",
    systemfonts::match_fonts("sans", italic=rep(c(TRUE, FALSE), 2), weight=rep(c("normal", "bold"), each=2))$path, 
    "</pre>", 
    sep="\n")
  </rcode>

  <p>
    A variable font is different because it effectively contains
    many different font variations within a single font file.
    The font provides a set of <emph>axes</emph> and we are able
    to select different values for each axis to produce
    variations on the font.
  </p>
  <p>
    There are five standard axes:
  </p>
  <ul>
    <li>
      <code>wght</code>:  The weight of the font, ranging from 1 to 1000,
      with normal weight typically 400 and bold typically 700.
    </li>
    <li>
      <code>slnt</code>:  The slant of the font, ranging from -90 to 90.
      This is a constant angle, distinct from italic variations of a font.
    </li>
    <li>
      <code>wdth</code>:  The width of the font, with a lower bound of 0 and
      no upper bound.  This allows condensed and extended variants
      of a font.
    </li>
    <li>
      <code>ital</code>:  The italic style of the font, ranging from 0 to 1.
    </li>
    <li>
      <code>opsz</code>:  The optical size of the font, with a lower 
      bound of 0 and no upper bound.  This allows for fine control of the
      details of glyphs when text is rendered at different sizes.
    </li>
  </ul>

  <p>
    In addition it is possible for a font to have a <emph>custom</emph>
    axis, which could be called anything (as long as it is four
    ASCII letters, all capitals) and could take any value (as long as
    it is a number).
  </p>

  <p>
    For example, the Recursive font that we have been using has 
    the standard <code>wght</code> axis that allows a wide range
    of font weights and a custom
    <code>CASL</code> axis that takes the values 1 or 0 and
    allows for a <emph>casual</emph> font
    style (or not).
  </p>

  <h2><a name="xdvir">Rendering glyphs with <str>xdvir</str></a></h2>

  <p>
    Using <code>grid.glyph()</code> directly, as
    demonstrated in the <a href="#intro"/>, is difficult because of the need
    to specify a font by file name and
    each glyph within the font by number, along with precise locations for
    each glyph.
    It is easier to use a package that figures out font file names,
    glyph numbers and
    positions for us.
    One example is the <str>xdvir</str> package (<a href="#xdvir-pkg"/>),
    which can render LaTeX fragments (with glyph rendering under the hood).
    For example, the following code draws the letter "t" using the
    Recursive font, just like in the first example of the
    <a href="#intro"/>, but with much less detail required from the user.
  </p>

  <rcode>
library(xdvir)
  </rcode>

  <rcode fig.width="1" fig.height="1">
grid.newpage()
grid.latex("t", 
           packages=fontspecPackage(font=fontpath), 
           gp=NULL)
  </rcode>

  <h2><a name="varfonts-xdvir">Variable fonts in <str>xdvir</str></a></h2>
  <p>
    Version 0.2-0 of the <str>xdvir</str> package 
    has added support for variable fonts (in LaTeX fragements).
    This takes two forms:  first of all, there are new arguments
    to the <code>fontspecPackage()</code> function that help with
    generating LaTeX fragments that make use of variable fonts;
    and secondly, there is a new <code>"luahbtex"</code> TeX engine
    that can comprehend the DVI output that is generated 
    from LaTeX code that makes use of variable fonts.
    For details about LaTeX packages and TeX engines in the
    <str>xdvir</str> package, see <a href="#RJ-xdvir"/>.
  </p>
  <p>
    For example, the following code draws the letter "t"
    using the Recursive font with a weight of 900.
    In order to set the font weight to 900, 
    it is necessary not only to specify 
    <code>axes=c(wght=900)</code>,
    but also to specify <code>renderer="harfbuzz"</code>,
    so that the variable font axis information is recorded in the DVI 
    output, and <code>engine="luahbtex"</code>, so that
    the DVI output is read into R correctly.
    It is also necessary to have a recent lualatex version with
    variable font support (1.17.0 at least).
  </p>

  <rcode fig.width="1" fig.height="1">
grid.newpage()
grid.latex("t", 
           packages=fontspecPackage(font=fontpath,
                                    renderer="harfbuzz",
                                    axes=c(wght=900)), 
           gp=NULL,
           engine="luahbtex")
  </rcode>

  <p>
    The next example demonstrates more complex control over the
    use of a variable font.  In this case, instead of setting up
    an overall font weight for the text in the LaTeX fragment, 
    we specify separate font weights
    for separate words.
  </p>
  
  <rcode fig.width="3" fig.height="1">
grid.newpage()
grid.latex(r"(
\addfontfeature{RawFeature={axis={wght=100}}}light
\addfontfeature{RawFeature={axis={wght=500}}}medium
\addfontfeature{RawFeature={axis={wght=900}}}dark
)",
           packages=fontspecPackage(font=fontpath,
                                    renderer="harfbuzz"), 
           gp=NULL,
           engine="luahbtex")
  </rcode>

  <p>
    Although the example above requires more complex LaTeX code,
    that code can easily be generated programmatically
    using basic tools, as demonstrated in the <code>addWeight()</code>
    function below.
  </p>

  <rcode>
addWeight <- function(label, weight) {
    paste0(r"(\addfontfeature{RawFeature={axis={wght=)",
           weight, "}}}", label)	      
}
addWeight(c("light", "medium", "dark"),
          c(100, 500, 900))	     
  </rcode>
  
  <rcode echo="FALSE" results="hide">
tex <- author("t", 
       packages=fontspecPackage(font=fontpath,
                                renderer="harfbuzz",
                                axes=c(wght=900)), 
       engine="luahbtex")
tex[1] <- substring(tex[1], 1, 100)
cat("<pre>",
    gsub(fontpath, "Fonts/", tex),
    "</pre>", 
    sep="\n")
  </rcode>


  <h2><a name="brathmap">Variable fonts in plots</a></h2>

  <p>
    Being able to specify axes for variable fonts is interesting and fun,
    but does it have any application to statistical graphics?
  </p>
  <p>
    <a href="#brath-banissi"/>
    propose that we can treat
    font weight as a visual channel that can be used to
    encode data values, just like the standard visual channels
    of position, length, colour, etc.
    For example, we can encode data values
    as the weight of text labels.
  </p>
  <p>
    As a demonstration of this idea, very loosely based on
    <a href="#brath-banissi"/> Figure 21, we will first produce
    a choropleth map, which encodes data values as the fill colour
    of map regions, then we will produce an alternative
    map that encodes data values as the weights of region labels.
  </p>
  <p>
    The following code uses
    <str>sf</str> (<a href="#sf"/>) and <str>dplyr</str> (<a href="#dplyr"/>) to
    set up the data for the map. This consists
    of youth crime rates (offenders per 100,000 population)
    in each police district of New Zealand
    for 2021 (from the
    <a href="https://www.justice.govt.nz/assets/Youth-Justice-Indicators-2021-FINAL.xlsx">Youth Justice Indicator Report 2021</a>).
  </p>
  
  <rcode message="FALSE">
library(sf)
library(dplyr)
crimeDistrict <- read.csv("YouthCrime/crime-district.csv") |>
    ## For joining with map data
    mutate(district = gsub("Bay Of Plenty", "Bay of Plenty",
                           gsub("Counties Manukau", "Counties/Manukau",
                                district)))
crimeDistrict <- subset(crimeDistrict,
		        year == 2021,
                        district != "Outside New Zealand (District)")
crimeDistrict$yearDate <- as.Date(paste0(crimeDistrict$year, "-06-30"))
districts <- 
    st_read("SHP/nz-police-district-boundaries-29-april-2021.shp",
            quiet=TRUE)
## Drop unnecessary Z dimension from some geometries
districts <- st_zm(districts)
centroids <- st_coordinates(st_centroid(st_geometry(districts)))
districts$X <- centroids[,1]
districts$Y <- centroids[,2]
districts <- inner_join(districts, subset(crimeDistrict, year == 2021),
                        by=join_by(D_MACRON == district))
  </rcode>

<p>
  The following code sets up a <str>ggplot2</str> plot (<a href="#ggplot2"/>)
  with the common aspects of the map.
  This will allow us 
  to more easily see how the code differs from
  a choropleth map to the label weight version.
</p>

  <rcode>
library(ggplot2)
gg <- ggplot() +
    scale_fill_continuous(name="crime rate", high="#132B43", low="#56B1F7") +
    coord_sf(expand=FALSE) +
    xlab(NULL) +
    ylab(NULL) +
    ggtitle("Youth Crime in New Zealand",
            "Distinct offenders per 10,000 pop.") +
    theme_minimal() +
    theme(plot.margin=margin(20, 0, 20, 0),
          axis.ticks=element_blank(),
          axis.text=element_blank(),
          panel.grid=element_blank(),
          legend.position="inside",
          legend.position.inside=c(1, 0),
          legend.justification=c(1, 0),
          legend.margin=margin(0))    
  </rcode>
<p>
  The following code generates a choropleth map that maps crime rate
  to the fill colour for each police district.
  The darker regions represent higher crime rates.
</p>
  <rcode message="FALSE">
gg + geom_sf(data=districts, aes(fill=rate), colour="white", linewidth=.6) +
     coord_sf(expand=FALSE)     
  </rcode>

  <p>
    The benefit of using a map like this is that we (Kiwis) can easily
    decode the geographic locations of different police districts
    because the shapes are familiar.
  </p>
<p>
  One problem with a choropleth map like this is that the police
  districts differ in terms of size as well as in terms of fill colour.
  This complicates the comparison of crime rates between police districts
  because the map regions differ in terms of fill colour <emph>and</emph>
  size <emph>and</emph> shape.
  Ideally, in order to effectively compare crime rates between police
  districts, the map regions would differ only in terms of fill colour
  (and position).
  This provides a motivation for an alternative encoding that
  does not rely on the size and shape of each police district.
</p>
<p>
  We will develop an alternative map that encodes crime rate as the
  weight of text labels.
</p>
<p>
  The first step is to transform the crime rate to a range
  of font weights.
  In the case of the
  <a href="https://fonts.google.com/specimen/Recursive/tester">Recursive font</a>, valid weights range from 300 to 1000.
</p>
  <rcode>
districts$rateStd <- 300 + 
                     700 * (districts$rate - min(districts$rate)) / 
                            diff(range(districts$rate))
  </rcode>

<p>
  There is a <code>geom_latex()</code> in the <str>xdvir</str>
  package, but it does not provide the flexibility that we require
  to select a local font file, so we will add text labels to
  each police district using the <str>gggrid</str> package
  (<a href="#gggrid"/>).
  The following code sets up a function to generate the police
  district labels as <str>grid</str> grobs that will draw LaTeX fragments.
  We make use of the <code>addWeight()</code> function from above
  to generate the LaTeX code that controls the font weight for each label.
</p>

  <rcode>
library(gggrid)
labelTeX <- function(data, coords) {
    label <- data$label
    tex <- addWeight(label, round(data$weight))
    latexGrob(tex, coords$x, coords$y,
              packages=fontspecPackage(font=fontpath,
                                       renderer="harfbuzz"), 
              engine="luahbtex",
              gp=NULL)
}
  </rcode>

<p>
  The following code draws the alternative map.
  We draw police districts as before, but this time they are all filled with the
  same (light grey) colour.
  A label is added for each police district with the crime rate encoded
  as the weight
  of the label.
  Bolder labels reflect higher crime rates.
</p>

  <p>
    With this map, we can still see the location of each police district,
    but now the crime rates are more easily compared because different
    crime rates are encoded simply as the font weights of the
    police district labels.
    It is also easier to identify the different police districts
    because they are now all labelled.
  </p>

  <rcode message="FALSE">
gg + geom_sf(data=districts, fill="grey90", colour="white", linewidth=.6)  +
     coord_sf(expand=FALSE) +
     grid_panel(data=districts, labelTeX, aes(X, Y, label=D_MACRON,
                weight=rateStd))
  </rcode>

  <h2><a name="summary">Acknowledgements</a></h2>
  <p>
    The original suggestion to add support for variable fonts came from
    Thomas Lin Pedersen, the author of the <str>marquee</str> package 
    (<a href="#marquee"/>), among many other 
    things.  The <str>marquee</str> package is similar to <str>xdvir</str>
    in that it can generate typeset glyph information, but it
    works from Markdown input rather than LaTeX fragments.
  </p>

  <h2><a name="requirements">Technical requirements</a></h2>
  <p>
    The examples and discussion in this report relate to 
    the development version of R (to become version 4.6.0) and 
    'xdvir' version 0.2-0.
  </p>
  <p>
    This report was generated within a Docker container
    (see <a href="#Resources">Resources</a> section below).
  </p>

  <h2><a name="Resources">Resources</a></h2>
  <ul>
    <li>
      The <a href="variable-fonts.cml">raw source file</a> for this
      report, a <a href="variable-fonts.xml">valid XML</a>
      transformation of the source file, a <a
      href="variable-fonts.Rhtml">'knitr' document</a> generated from
      the XML file, 
      two <a href="toc.R">R</a> <a href="bib.R">files</a> and
      the <a href="variable-fonts.bib">bibtex file</a>
      that are used to generate the table of contents and reference sections,
      two <a href="common.xsl">XSL</a> <a
      href="knitr.xsl">files</a> and an 
      <a href="knit.R">R file</a> that are used to transform the XML to
      the 'knitr' document, and a <a href="Makefile">Makefile</a> that
      contains code for the other transformations and coordinates
      everything.  
      These materials are also available
      on <a href="https://github.com/pmur002/variable-fonts-report/releases/tag/v1">github</a>.
    </li>
    <li>
      This report was generated within a 
      <a href="https://www.docker.com/">Docker</a> container.
      The Docker command to build the report is included in the Makefile above.
      The Docker image for the container is available from
      <a href="https://hub.docker.com/r/pmur002/variable-fonts-report/">Docker Hub</a>;
      alternatively, the image can be rebuilt from its 
      <a href="Dockerfile">Dockerfile</a>.
    </li>
  </ul>

  <h2>How to cite this report</h2>
  <p>
    Murrell, P. (2025). "Variable Fonts in R Graphics" 
    Technical Report 2026-??, Department of Statistics, The University of Auckland. 
    Version 1.
    [ <a href="how-to-cite.bib">bib</a> |
      <a href="">DOI</a> | 
      <a href="">http</a> ]
  </p>

  <h2><a name="references">References</a></h2>
  <ul style="list-style-type: none">
    <li>
      <a name="xdvir-pkg"/>
    </li>
    <li>
      <a name="R"/>
    </li>
    <li>
      <a name="RJ-xdvir"/>
    </li>
    <li>
      <a name="brath-banissi"/>
    </li>
    <li>
      <a name="ggplot2"/>
    </li>
    <li>
      <a name="sf"/>
    </li>
    <li>
      <a name="dplyr"/>
    </li>
    <li>
      <a name="gggrid"/>
    </li>
    <li>
      <a name="marquee"/>
    </li>
  </ul>

  <hr/>
  <p>
    <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/"><img class="CC"
    alt="Creative Commons License" style="border-width:0"
    src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span
    xmlns:dct="http://purl.org/dc/terms/"
    property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#"
    property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>

</body>
</html>
